0x7f05 6f94 b000
          4000 0000
do_data_copy_enqueue|elem.dst:0x7f8d70709680, elem.src:0x7f8c69879980, elem.len:60
heap에서 alloc한 포인터 0x7f8d705b2f80

heap->last는 0x7f8d8713bf80

stack grows toward lower address

heap grows toward higher address 


56이 0번포트
4a가 1q번포트
0x7f0e f224 4000   0-0 포트 0번꺼  -> rte_eal_init 에서 eal_check_mem_on_local_socket() memseg_list_walk_thread_unsafe 보면, 얘만 존재한다.
25399 ret value:1 base_va:0x7f0ef2244000 page_sz:1073741824

rte_service:0x7f0f 3224 2000 이게 rte_service_init에서 실행돼 ( 이게 calloc으로 받아온건데 이게 malloc_socket에서 받아온것으로,
malloc_socket은 available socket의 메모리를 사용한다) 
그래서 ptr을 return 하는데 이 ptr은 malloc_heap_alloc(type(rte_service),size(8192)) 이런식으로 호출한다.
이 socket의 id는 0이야.

처음에 heap_alloc 들어갔을 때 이 함수는 heap으로부터 block of memory를 받아오기 위함이야.
이는 free list를 lock하고, scan하고, add a new memsegment if scan fails. 
새 memsegment가 added면, re-scans and should return the new element after releasing the lock.

처음에보면,  @!0!@allocate heapname=socket_0 heap->last=(nil) heapsize=0 element

heap이 아무것도 없어. 

그래서elem = find_suitable_element(heap, size, flags, align, bound, contig);
이걸 불러서 들어가보면, 

msl->base_va, msl->page_sz 

0x7f0f 1b80 f680 src가 이거인 do_data_copy_enqueue

0x7f0f 1b80 f680

0x7f0e b224 4000




0x7f0e 2987 9980
          4000 0000

0x7f0f 1b80 f680

0x7f0 5a  f94b000

0x7f0 56  f94b000


shared memory 

56 ~ 5a 까지 쓸수있다


if(resize_and_map) 에 들어가면 shared address 주소인 data주소랑 같은게 반환된다.
 
0x7f0ef2244000
        2947A100



drivers/net/vhost/rte_eth_vhost.c -> eth_dev_vhost_create에서 정의된 tx_pkt_burst-> eth_vhost_tx ->rte_vhost_enqueue_burst
lib/librte_vhost/virtio_net.c  -> (rte_vhost_enqueue_burst) ->(virtio_dev_rx) -> virtio_dev_rx_split |||||||  host-> container


drivers/net/vhost/rte_eth_vhost.c -> eth_dev_vhost_create에서 정의된 rx_pkt_burst-> eth_vhost_rx ->rte_vhost_dequeue_burst
lib/librte_vhost/virtio_net.c -> (rte_vhost_dequeue_burst)->(virtio_dev_tx) -> virtio_dev_tx_split   |||||||||container-> host 

포인터만 저장하는거
ixgbe는 dev->rx_pkt_burst = ixgbe_recv_pkts_vec (우리 black host)
컨테이너 안에서는
drivers|net|virtio|virtio_ethdev.c| tx=virtio_xmit_pkts_inorder  이게 
drivers|net|virtio|virtio_ethdev.c| rx=virtio_recv_pkts_inorder
이건 drivers|net|virtio|virtio_rxtx.c 에 존재.
가 실행된다.

eth_dev->tx_pkt_burst = eth_vhost_tx;   
아래의 tx_pkts 라는 rte_mbuf ** 배열은, iofwd.c에 정의된  struct rte_mbuf *pkts_burst[MAX_PKT_BURST];
호출은 (*dev->tx_pkt_burst)(dev->data->tx_queues[queue_id], tx_pkts, nb_pkts);
실행은 eth_vhost_tx(void *q, struct rte_mbuf **bufs, uint16_t nb_bufs)

1,398,101 이만큼의 64바이트 패킷을 쓸 수 있다. (192를 차지한다는 가정하에)

used ring에 있는 mbuf해제할 때 처럼 다시 해제 
155167 개만 받았다.

fp=fopen("/home/black/malloc_he_alloc_on_heap_id.txt","a");


이게 컨테이너의 첫 패킷 주소값                                                     0x1697f8940 (cookie 값)  
이게 host에서 보내는 첫 패킷 dst 값                                           0x7f2ee97f8a40 
						차이 :    0x7F2D 8000 0100

이게 두번째                                                                                0x1697f9280 (cookie 값)
이게 host에서 보내는 두번째 패킷 dst 값                                     0x7f2ee97f9380
						차이 :    0x7F2D 8000 0100
								1
							0x7F2D 8000 0101
							1값을 얻고 + memeory_segment 를 참조하도록 바꿔놓기

lib/librte_vhost/virtio_net.c






lib/lirte_vhost/vhost_user.c/virtio_is_ready 를 보면 여기서 virtio is now ready for processing이 불리니까.
이거 전에 file을 열어서 /home/black/cpp/a.cpp 와 같이 포인터주소를 받아와서 (container에서는 shmat할때 파일로저장)
여기서 이제 /lib/librte_vhost/vhost.h에 추가된 전역변수에 포인터를 저장한다.

그럼 dev_rx_split 에서 copy_mbuf_to_desc안에를 보면, batch_copy 쯤에서 desc[i].addr을 접근하면
이게 virtio_recv_pkts_inorder (docker안에서불리는) desc[i]->addr에 접근하는거랑 같은 주소란 말야

즉 desc[i].addr= host의 shared memory 출발지에서 얼마나 떨어져있는지 offset + docker에서 배정한 sharedmemory pointer 연산
이런식으로 배정하고
virtio_recv_pkts_inorder에서 desc[i]->addr에 접근해서 이걸 cookie대신써.

나중에 memory는 해제 안해도되고, 그냥 다시 처음거에 덮어쓰자. memset(shrmem시작점, 0,임의의 패킷개수 * sizeof(rte_mbuf)) 이런식으로
뭐 한계를 50000개 정도로 정해놓고 memset으로 한번에 ?

sudo docker run -it --privileged -v /mnt/huge:/mnt/huge -v /home/byeon/dpdk-stable-20.11.2:/var/run -v /home/cont/dpdk-stable-20.11.2:/home  -v /dev:/dev --ipc=host bruzn/ubuntunetplus:2.0  /bin/bash

0x 7f8815d85000 이게 host shm 시작점
0x 7f887f34b340 이게 패킷 src
0x 7fb8ef4c8340 이게 container쪽 받은 패킷 src ( desc->addr)
0x 7fb885f02000  cont쪽 shm 시작점


0x 7f88 15d8 5000 이게 host shm 시작점
0x 7f88 7f34 b340 이게 패킷 src
0x 7fb8 ef4c 8340 이게 container쪽 받은 패킷 src ( desc->addr)
0x 7fb8 85f0 2000  cont쪽 shm 시작점

0x 7fb8 85f0 2000
0x 7f88 7f34 b340


695C 6340 이게 offset


0x7fce cc57 a680 이게 컨테이너에서 받은 addr
0x7fce 62fa f000 이게 시작점
0x7f0f 312f d000 이게 host 시작점


0x7fce cc57 a680

m은 0x7f0f 9a8c 8580
0x7f0f 9a8c 8600
m->bufaddr은 0x7f0f9a8c8600

===set_rxtx_funcs virtio/virtio_ethdev.c===                                                    │build.ninja  cscope.out           dpdk-stable-20.11.2_cont  v20.08.tar.gz
|drivers|net|virtio|virtio_ethdev.c| tx=virtio_xmit_pkts_inorder                               │cont_dpdk    dpdk-stable-20.11.2  dpdk-stable-20.11.2_succ
|drivers|net|virtio|virtio_ethdev.c| rx=virtio_recv_pkts_inorder                               │byeon@black-Z10PA-U8-Series:~$ ls
|drivers|net|virtio|virtio_rxtx.c|addr=0x7fcecc57a680  [i]=0                                   │build.ninja  cscope.out           dpdk-stable-20.11.2_cont  v20.08.tar.gz
|drivers|net|virtio|virtio_rxtx.c|cookie addr=0x7fcecc57a680


지금 cookie 바꾼데에서 문제가 생겨 (segmentation fault)
왜냐 기존에 src 패킷 

sshp = host의 0번 포트 공유메모리 주소 : 0x7fda6f668000


lib/librte_eal/linux/eal.c docker 안에서 shmat으로 공유메모리주소 열음
0x7f68811cc000이야 그게 (도커쪽 shmmem시작점)
0x7fda98c33680 이 패킷 보내는 주소.(host쪽 패킷주소)
0x7fda6f668000 host쪽 패킷 공유메모리
0x7f68811cc000 저 차이를 구해서 여기에 더해주면된다.


failing point

vi drivers/net/virtio/virtio_rxtx.c

virtqueue_dequeue_rx_inorder(vq,rcv_pkts,len,nb_used);
밑에
header에 (char*)로 접근하는 buf_addr이 접근불가능한 영역이니까
if(vtpci_with_feature ) 문 아래에서
이걸 접근하려니까 오류가나는거지.


0x7f66e55b5000 container shmmem
0x7f670eb80680 패킷주
  1 내 생각에는
  2 driver code process test-pmd process 가달라서
  3 sharedmemory file
  4 driver process test-pmd process shared memory 접근권한이 있나?
  5 
  6 
  7 너의생각
  8 
                             

제안서


0x7f6ec8117b80 이게 CONTAINER에서 받은 ADDR

0x7f6ec811c580 이게 넣은 addr 

m->buf_addr= 0x7f6ec811c600


0x7f6614063580
0x7f6614063580


0x7f04f826a000 
0x7f0521835680 ea주소

0x7f0521835580 m주소

0x7f0521835600 우리가 바꾼m-> bufaddr


0x7faa127379c0 3번째꺼 ==cookie[0]
0x7faa127379c0

0903-
자 이제 txvq send 위에있는
virtqueue_enqueue_xmit_inorder에서 cookie에 담기는 주소값을 조정하든지 해서 
이쪽 black에서 받을 수 있도록 해야한다.
그전에 black쪽의 

drivers/net/vhost/rte_eth_vhost.c -> eth_dev_vhost_create에서 정의된 rx_pkt_burst-> eth_vhost_rx ->rte_vhost_dequeue_burst
lib/librte_vhost/virtio_net.c -> (rte_vhost_dequeue_burst)->(virtio_dev_tx) -> virtio_dev_tx_split
이 루틴을 통해서 패킷을 받는데, 둘이 desc[i]번째가 공유되는지를 보던가 (rx때 썼던 방식처럼)

아니면 뭐, cookie값을 변경

0x7faa127379c0 이게 container의 shared memory + offset
0x7faa127379c0

eth_vhost_tx가 끝나고나서부터 계속 fill_vec_buf_split이 불린다. 
즉 virtio_dev_tx_split

0x7fb8aa227580

0x7f6663acc580 ==cookie

0x7f6663acc674 ==addr

+F4
컨테이너는 testpmd.h?
black은 <rte_> 어디에 해놨으니 알아서 찾도록.


log/original.txt
컨테이너의 /orig.txt 가 
/home/byeon/host_orig
/home/byeon/cont_orig

0907_abnormal_finish

패킷이 32개가 다 가긴하는데, desc[idx].addr= 에 넣어서 넘기는데 
[0~11] 에 들어있으면 [12]에 엑세스하고 이런문제.

이후 현재 9개받은상태.

알고보니 copy_enqueue 그 함수에서 batch_copy_elems 를 0으로만들길래 그걸로 했더니 9개만 가고 segfault
알고보니, 원래도 0으로만드는게맞는데.


host쪽에서

변경된곳

lib/librte_eal/common/eal_common_memory.c ->eal_memseg_list_alloc_shared

전역변수로 넣어주는곳

lib/librte_vhost/vhost_user.c virtio_is_ready

rte_malloc.h ( lib/librte_eal/include)에 시간변수

drivers/net/ixgbe/ixgbe_rxtx_vec_sse.c  rte_eth_rx_burst가 부르는 ixgbe_recv_pkts_vec recv_raw_pkts_vec 에서 starttime찍고


byeonmod : 기존 byeon에다가 수정한것.