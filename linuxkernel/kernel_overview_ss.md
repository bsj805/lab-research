<https://secmem.tistory.com/483>

커널 내용 정리
리눅스 최신 커널 소스는 http://www.kernel.org

VM에서 보면 /usr/src/linux에 없던데 이는 VM에서는 kernel을 hypervisor를 통해 window껄 이용하기 때문일까/.
<https://www.youtube.com/watch?v=81j1WF5xEZc>
이것도 흥미로운 cgroup이야기.


커널은 프로세스가 아니라 스레드를 스케줄링한다.
리눅스에서의 스레드는 조금 특별한 형태의 프로세스.
리눅스 커널은 프로세스 목록을 태스크 리스트라는 양방향 연결리스트 형태. (ring 모양으로 )
task list는 linux/sched.h에 정의된 struct task_struct 형식. 프로세스 서술자라고 부른다.
task_struct에는 프로세스와 관련된 모든 정보가 들어있다. 사용중인 파일, 프로세스 주소 공간, 대기 중인 시그널, 프로세스의 상태 등.

이 task_struct 구ㅡ조체는 객체 재사용 및 캐시 컬러링 기능을 지원하는 슬랩 할당자를 사용해서 할당한다.
short int의 최대값인 32768이 pid의 최대값.
linux/thread.h에 정의.
 
 모든 프로세스의 부모는 PID 1. 그래서 어떤 프로세스던 다른 프로세스에 reach가능. 
 커널에서는 스레드가 존재하지 않고, 프로세스로 모든 스레드를 구현한다. 그래서 쓰레드 대상 자료구조나 스케줄링 기법이 존재 x
 그냥 자원을 공유하는 경량화된 프로세스 정도
 
 XV6 에서 했던것처럼 system call 함수 정의하면 커널 내부에서는 sys_함수명 으로 정의된다.
 syscall 추가과정은, 
 1. syscall table의 마지막에 항목 추가
 2. syscall 번호를 asm/unistd.h 파일에 정의
 3. syscall을 kernel image로 compile (새로운 커널이 되어라)
 
 장치의 일부 설정을 바꾸거나 설정 정보를 얻고자 할 때엔 ioctl() 함수를 사용한다.
 
 인터럽트 동작과정
 
 하드웨어로부터 전기신호 받으면 interrupt controller에게 전달, cpu는 그걸 받아 현재 실행하는 일 중단 
 OS에 인터럽트 발생 사실 전달하고, 운영체제는 상황에 맞게 처리한다.
 
 운영체제는 인터럽트를 구별하고 인터럽트가 발생한 하드웨어를 식별한다. 이런 인터럽트 값을 IRQ 라인이라고 부른다.
 
 
 리눅스의 인터럽트 핸들러: 인터럽트를 처리하기 위해 커널이 실행하는 함수
 리눅스는 그냥 c 함수인데, 커널이 호출하고, interrupt context라는, user도 kernel context도 아닌 특별한 context에서 실행된다.
 이 컨텍스트 에서는 중단이 불가능해서 unit context 라고도 부른다. (단위 컨텍스트) 
 핸들러의 속도가 빨라야 해 ( 핸들러 실행시간이 짧아야해) 
 
 인터럽트 처리가 빠르고, 대량 작업을 실행해야 하니,
 인터럽트 처리는 2부분으로 나뉜다.
 전반부 처리는 인터럽트 핸들러가 담당, 인터럽트 즉시 실행되며, 인터럽트 수신확인, 하드웨어 재설정 처럼 중요한 작업만 빠르게 처리
 (top-half)
 후반부 처리는 나중에 할 수있는 일들 (bottom half)
 
 인터럽트 핸들러는 하드웨어 관리하는 드라이버가 담당,. 장치별로 드라이버가 있고, 인터럽트를 사용하는 장치라면 드라이버가 인터럽트 핸들러를 등록
 
 드라이버는 <linux/interrupt.h> 에 정의된 request_irq() 함수로 인터럽트를 활성화하고, 인터럽트 핸들러를 등록한다.
 
 기존 후반부 처리방법이 bottom half였다면, (BH방식)
 
 현재는 지연처리를 위해 softirq, tasklet, work queue가 존재한다.
 
 tasklet이 softirq기반이다. 
 <https://secmem.tistory.com/610>
 
 kernel/softirq.c 파일.
 컴파일 시에 정적으로 할당되므로, 동적으로 등록/제거 불가능.
 
 직접 softirq를 사용하는 서브시스템은 네트워크와 블록장치, 커널 타이머, 
 태스크릿은 동적으로 생성이가능, 락 사용이 덜 엄격해. 하지만 자체적으로 효율적 락 관리가 가능하고 실행시간이 중요하다면 softirq를 사용한다.
 
 work queue는 지연 작업을 커널 쓰레드 형태로 처리한다. 이 후반부처리는 프로세스 컨텍스트에서 실행.
 스케줄링이 가능하고 휴면상태로 처리 될 수 있다. 지연되는 작업이 휴면 상태로 전환될 필요가 없다면 softirq나 태스크릿을 사용한다. 
 
  
